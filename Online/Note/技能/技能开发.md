
<!-- TOC -->

- [示例代码](#示例代码)
    - [API](#api)
        - [CRole](#crole)
        - [CGame](#cgame)
        - [CanTriggerMeParam](#cantriggermeparam)
        - [CanCastParam](#cancastparam)
        - [CSpellMgr](#cspellmgr)
        - [CRoleSpellMgr](#crolespellmgr)
        - [CPhaseMgr](#cphasemgr)
        - [CCardDataRepository](#ccarddatarepository)
        - [CPlayCard](#cplaycard)
        - [CZoneBase](#czonebase)
        - [CDamageAction : public CAction](#cdamageaction--public-caction)
        - [CAddHpAction : public CAction](#caddhpaction--public-caction)
        - [CMoveCardAction : public CAction](#cmovecardaction--public-caction)
        - [CUseCardAction : public CAction](#cusecardaction--public-caction)
        - [CSpell : public CAction](#cspell--public-caction)
        - [Sha : public CSpell](#sha--public-cspell)
        - [CSubstituteSpell : public CSpell](#csubstitutespell--public-cspell)
        - [CPlayCardData : public CCardDataBase](#cplaycarddata--public-ccarddatabase)
        - [All](#all)
    - [常用逻辑](#常用逻辑)
        - [随机值](#随机值)
        - [总伤害值](#总伤害值)
        - [转化牌](#转化牌)
        - [响应选择多张牌](#响应选择多张牌)
        - [响应弃置多张牌](#响应弃置多张牌)
- [编写指南](#编写指南)
    - [命名习惯](#命名习惯)
        - [肉鸽](#肉鸽)
        - [比赛](#比赛)
        - [宏注册DATA,STATE](#宏注册datastate)
    - [测试](#测试)
    - [合并](#合并)
    - [注意](#注意)
    - [上传](#上传)
    - [联调](#联调)
    - [策划](#策划)
    - [配置](#配置)
    - [前端](#前端)
        - [log](#log)
        - [备注](#备注)
        - [StoC](#stoc)
        - [CtoS](#ctos)
        - [总结](#总结)
    - [战功模板](#战功模板)
    - [技能模板](#技能模板)
- [示例技能3](#示例技能3)
    - [药理](#药理)
    - [飞扬](#飞扬)
- [示例技能2](#示例技能2)
    - [武烈](#武烈)
    - [英魂](#英魂)
    - [笃烈](#笃烈)
    - [义绝](#义绝)
    - [除疠](#除疠)
    - [冲阵](#冲阵)
    - [列侯](#列侯)
    - [醇醪](#醇醪)
    - [弘德](#弘德)
    - [实荐](#实荐)
    - [誉虚](#誉虚)
    - [突袭](#突袭)
    - [镇军](#镇军)
    - [狞恶](#狞恶)
    - [援资](#援资)
    - [烈节](#烈节)
    - [英姿](#英姿)
    - [制衡](#制衡)
    - [甘露](#甘露)
    - [弓骑](#弓骑)
    - [恃才](#恃才)
    - [渐营](#渐营)
    - [潜袭](#潜袭)
    - [父魂](#父魂)
- [示例技能1](#示例技能1)
    - [执笏](#执笏)
    - [移荣](#移荣)
    - [开济](#开济)
    - [垦伤](#垦伤)
    - [苦肉R](#苦肉r)
    - [破军R](#破军r)
    - [狼袭R](#狼袭r)
    - [义从](#义从)
    - [趫猛Y](#趫猛y)
    - [怀异Y](#怀异y)
    - [缮甲Y](#缮甲y)
    - [奋音S](#奋音s)
- [说明](#说明)
    - [常用文件](#常用文件)
    - [常用时机注册](#常用时机注册)
    - [三服不同](#三服不同)
- [备注](#备注-1)
- [bug](#bug)
- [测试常用](#测试常用)
    - [牌](#牌)
    - [技能](#技能)
    - [作弊](#作弊)

<!-- /TOC -->

# 示例代码

## API
### CRole
```cpp
- 牌区和手牌上限
GetHandCardZone();
GetHandCardSize();
IsHandZoneEmpty();
EmptyPlayCard();
GetMyPlayCardCount()
GetHandCardLimit();
CheckNotifyHandCardLimit();//核查并操作手牌上限变动
HaveHandOrEquipCard(unsigned int uCardId)const;//玩家是否有此牌(手牌中 装备牌中)
GetMyPlayCard(unsigned int uCardId)const;//根据卡牌ID得到我的卡牌
GetMyHandPlayCard(unsigned int uCardId)const;//根据卡牌ID得到我的手牌

- 牌的变化
GetDiscardCntInRolePhase(unsigned int rolePhase);//此阶段弃牌数
- 体力和上限
GetCurHp();
GetLostHp();
SetMaxHp(int hp);
IncCurHp(unsigned int seatid_healer, unsigned int spellid, int hp = 1);
- 伤害
GetDamageHpOneTurn();//本回合总伤害值
AddDamageHpOneTurn();//记录增加本回合总伤害值
- 距离和范围
GetAttRange();     //攻击范围
GetAttDistance();  //进攻马距离
GetDefDistance();  //防御马距离
GetSeatId();
- BUFF
IsAttRangeNoLimit(); //攻击距离无限制
IsUseShaNoLimit(); //使用杀无限制
- 技能
GetSpellUseTimes(unsigned int spell_id);
AddSpellUseTimes(unsigned int spell_id, bool ntfclient = true, unsigned int reset_type = 0);

GetCardSpellUseTimeCountRound(unsigned int nSpellId, unsigned int nSubType = (unsigned int)YOKA_SKILL::INVALID_SPELL_ID);//获取本轮对应技能的使用次数
GetCardSpellUseTimeCountTurn(unsigned int nSpellId, unsigned int nSubType = (unsigned int)YOKA_SKILL::INVALID_SPELL_ID);//获取本回合对应技能的使用次数
GetShaSpellUseTimeCountTurnAllSubType();//获得杀的总使用次数

pRole->IsCharacterHasSpellIncludeUnusable(pParam->uCharacterId,  (unsigned int)YOKA_SKILL::SKILL_JIE_XIAN_CHARACTER_WU_SHENG, &spellParam)//是否有技能
- TO3
GetSpellStateMgr();//CRoleSpellMgr
- 3TO
pGame->GetCurrentTurnRole()//当前回合角色
pGame->GetRoleBySeatId(pParam->seat_id);
pGame->GetRoleBySeatId(pParam->targets.at(0));
pParam->GetCaster()//CanCastParam
GetHurter()//伤害来源
GetTarget()//受伤角色
pPlayCard->GetOwner()//CRole
pUseCardAction->GetCardUser();//CRole
pZoneBase->GetPlayCardOwner();//CRole
pSpell->GetCaster()//CRole
GetCurTargetRole();

```
### CGame
```cpp
- 其他类
GetPhaseMgr()//CPhaseMgr
GetGameStartTime();
- 牌时机
GetCurrentTurnRole()//当前回合角色
GetCurrentPhase()//当前阶段
- 牌
GetPlayCard(cardid);//id获取牌
GetDiscardZone();
DealCard(pHurter, nDealCardCnt, pCaster, GetSpellId());//摸牌
- 座位
GetRoleBySeatId(pParam->seat_id);//CRole
GetRoleSeatIdListAll(seatIdList, true);//SeatIdList seatIdList;存活座位/所有座位的id
GetRoleListAll(roleList, true);//PRoleVct roleList;存活座位/所有座位的角色
```

### CanTriggerMeParam
```cpp
pParam->seat_id
pParam->pTriggerAction->get_opp() == CTriggerAction::Opp_phase_begin
pParam->uTriggerIndex//技能效果分支
pParam->paramList.push_back(card->GetCardId());
pParam->targetList.push_back(pRole->GetSeatId());

pParam->paction//CAction
pParam->uCharacterId
pParam->bParamLocked = true;
pParam->bLocked = true;
pParam->bNotNotifyClient = true;
pParam->bTargetLocked = true;////（武将技或者装备技能）不是锁定技时,使用技能时目标是否会被自动赋值成targetList
```

### CanCastParam
```cpp
pParam->GetCaster()
pParam->psrc_role
pParam->targets//选中目标
pParam->use_cardlist//选中牌
CDamageAction* pDam = dynamic_cast<CDamageAction*>(pParam->psrc_action);//注意区分paction
castParam.SetMark(CanCastParam::mark_ignore_distance);//无视距离/无视次数

- 3TO
CanCastParam castParam;
```

### CSpellMgr
```cpp
CSpellMgr::single()->CanDiscard(*pTarget, *pCard, GetSpellId())
CSpellMgr::single()->CanNotUseCard(castParam.spellid, castParam)
CSpellMgr::single()->IsTargetInAttackRange(*pRole, *item)//攻击范围内
CSpellMgr::single()->CanBeTarget(castParam, item, false)
```

### CRoleSpellMgr
```cpp
CQianXiJState* pState = dynamic_cast<CQianXiJState*>(GetCaster()->GetSpellStateMgr()->FindSpellState(GetSpellId()));
CQianXiJState* pState = GetCaster()->GetSpellStateMgr()->AddSpellStateEx<CQianXiJState>(GetCaster(), GetSpellId());
Roguelike_LieJieData* pData = dynamic_cast<Roguelike_LieJieData*>(GetCaster()->GetSpellStateMgr()->GetData(SpellId()));
```
### CPhaseMgr
```cpp
IsInTurn()//处于某个回合中
IsCurrentRole(pRole)//处于指定角色回合内
```
### CCardDataRepository
```cpp
CCardDataRepository::Singleton(pGame->GetGameStartTime())->GetCardTypeBySpellId(pSpell->GetSpellId()) != CARD_TYPE_NORMAL//牌类型
CCardDataRepository::Singleton(pGame->GetGameStartTime())->IsNormalStratagem(pSpell->GetSpellId())//牌类型
auto* spellExtend = CCardDataRepository::Singleton(pGame->GetGameStartTime())->GetActivitySpellExtendData(pGame->GetLabelModel(), SpellId(), pGame->GetDifficultId());//配置
```
### CPlayCard
```cpp
cardSuitList.push_back(pPlayCard->GetSuit());
CPlayCard::GetPlayCardColorBySuitList(cardSuitList);//CardIdList cardSuitList;列表只存储花色0-4

- TO3
GetZone()//CZoneBase
GetOwner()//CRole
```
### CZoneBase
```cpp
GetZoneType()!=ZONE_DISACARPILE
GetPlayCardList()//PPlayCardList&
GetPlayCardOwner()//CRole
Find(cardId);

```

### CDamageAction : public CAction
```cpp
IsDamagePrevent()//伤害是否被防止
GetHurter()//伤害来源
GetTarget()//受伤角色
GetSrcAction()
AddDamageHp(1);
CDamageAction::Damage(GetGame(), GetCaster()->GetSeatId(), pTarget->GetSeatId(), this, cnt);//造成伤害
CDamageAction::LoseHp(GetGame(), *GetCaster(), this, cnt);//失去体力
- 3TO
CDamageAction* pDamAc = dynamic_cast<CDamageAction*>(pParam->paction);
```

### CAddHpAction : public CAction
```cpp
CAddHpAction::AddHp(GetGame(), GetCaster(), GetCaster(), add_hp, this);
```

### CMoveCardAction : public CAction
```cpp
const CMoveCardAction::MoveCardActList& rMoveCardList = pMoveAc->GetMoveCardActList();//移动事件列表
CMoveCardAction* pMove = CMoveCardAction::MoveCardsFromRole(pGame, EmActMode::Mode_DisCard, cards, seats, pCaster->GetSeatId(), pCaster, GetSpellId(), pCaster->GetSeatId(),&pGame->GetDiscardZone(),sc_invalid_seat_id);//弃牌
CMoveCardAction::RevealCard(GetGame(), GetCurTargetRole(), GetSpellId(),m_card->GetZone(), PPlayCardList{ m_card },ntfseatList, true, true);//展示
- TO3
CUseCardAction* pUseCardAc = dynamic_cast<CUseCardAction*>(pMoveAc->GetFromAction());

```

CMoveCardAction::TMoveCardsAct
```cpp
for (CMoveCardAction::MoveCardActList::const_iterator iter = rMoveCardList.begin(); iter != rMoveCardList.end(); ++iter)
{const CMoveCardAction::TMoveCardsAct& rMoveAct = *iter;}//遍历移动事件

rMoveAct.pFromZone//CZoneBase
rMoveAct.pToZone//CZoneBase
rMoveAct.sucessPlayCardList//SucceedMoveCardList
```

### CUseCardAction : public CAction
```cpp
//3TO
CUseCardAction* pUseCardAction = dynamic_cast<CUseCardAction*>(pParam->paction);
CUseCardAction* pUseCardAction = pSpell->GetUsedCardAction();

pUseCardAction->GetCardUser();//CRole
pUseCardAction->GetPlayCards();//PPlayCardList&

```
### CSpell : public CAction
```cpp
pSpell->GetCaster()//CRole
pSpell->GetUsedCardAction()//CUseCardAction
pSpell->GetCardList()//CardIdList&
pSpell->AddBaseDamage(1);
- 3TO
CSpell *pSpell = dynamic_cast<CSpell*>(pParam->psrc_action);
CSpell* pSpell = dynamic_cast<CSpell*>(GetSrcAction());

```
### Sha : public CSpell
```cpp
pSha->GetCardList().empty()//虚拟杀
pSha->GetSubstituteSpell() != nullptr//转化杀
GetCaster();//使用者
unsigned int seatid = pSha->GetCurTarget();//目标id
GetDamageTargetMap()//目标和对应伤害
- 3TO
Sha* pSha = dynamic_cast<Sha*>(pParam->psrc_action);
```

### CSubstituteSpell : public CSpell
```cpp
eSpellCastResult rt = CSubstituteSpell::CanCast((unsigned int)YOKA_SKILL::SKILL_ROGUELIKE_BUFF_WUSHENG, (unsigned int)YOKA_SKILL::SKILL_SHA, pGame, pParam, PHASE_MAX_CNT);//牌能否转化
if (rt != SPELL_CAST_OK)
    return rt;
```

### CPlayCardData : public CCardDataBase
```cpp
spellData->GetDefaultSpellId(0) == (unsigned int)YOKA_SKILL::SKILL_SHA//是杀
- 3TO
CPlayCardData* spellData = CCardDataRepository::Singleton(pGame->GetGameStartTime())->GetPlayCardData(pSha->GetCardList().front());

```

### All
```cpp
//流程
switch (GetResolveStep())
if (GetSpellEffectIdx() == effect_deal_card)
SetResolveStep(step_ask_reveal);
SetOverMark();
ClearAllOfWaitingOpt();

//角色
GetCaster()
GetCurTargetRole()

GetTriggerParams();//一般为牌id列表
GetTargetList();//座位id列表
//牌
DisCardFromRole(GetCaster(), pTarget, cardlist);
```

## 常用逻辑

### 随机值
```cpp
unsigned int count = CSgsPubFun::rand_uint(lowerLimit, upperLimit);
```

### 总伤害值
```cpp
unsigned int nCount = 0;
for (auto item : pSha->GetDamageTargetMap()){
    nCount += item.second;
}
```

### 转化牌
```cpp
KenShang::KenShang(const CCardSpellData *pSpellData, CGame *pGame) :CSubstituteSpell(pSpellData,pGame,0)
{
	SetStituteSpellId((unsigned int)YOKA_SKILL::SKILL_SHA);//杀
	SetSubType(CARD_SUB_TYPE_INVALID);//普通杀
	SetbEquit(true);//可转化装备
}
```

### 响应选择多张牌
```cpp
CRole *ptarget = GetCurTargetRole();

//选中随机牌
PPlayCardList hand_cards;
ptarget->GetHandCardZone()->Random((pMsg->cardCnt - pMsg->dataCnt), hand_cards);

//选中指定牌
PPlayCardList equip_cards;
for (unsigned int i = 0; i < (unsigned int)pMsg->dataCnt; ++i)
{
    CPlayCard* pcard = ptarget->GetEquipCardZone()->Find(pMsg->data[i]);
    if (!pcard)
    {
        APPLOG_ERROR_GAME_LOGIC("client logic error equip id=" << pMsg->data[i] << FUN_FILE_LINE);
        return;
    }
    equip_cards.push_back(pcard);
}
```

### 响应弃置多张牌
```cpp
void Roguelike_GongQi::NetMsgMoveCardRpy(const MsgMoveCard *pMsg, CGsUser *pUser)
{
	if (!pMsg || !GetCaster() || !GetGame())	
	{
		SetOverMark();
		ClearAllOfWaitingOpt();
		Log_BaseInfo(GetSpellId(), GetGame(), pUser, true);
		if (NULL == pMsg)
			APPLOG_ERROR_GAME_LOGIC("pMsg = NULL" << FUN_FILE_LINE);
		if (NULL == GetCaster())
			APPLOG_ERROR_GAME_LOGIC("m_pSrc=NULL" << FUN_FILE_LINE);
		return;
	}

	if (GetResolveStep() != step_wait_discard)
	{
		return;
	}

	CRole* pRole = GetGame()->GetRoleBySeatId(pMsg->srcSeatId);
	if (!pRole)
	{
		CSpell::Log_BaseInfo(GetSpellId(), pRole, true);
		if (!pRole)
			APPLOG_ERROR("pTarget = NULL" << FUN_FILE_LINE);
		return;
	}

	CRole* pTarget = GetCurTargetRole();
	if (!pTarget || !pTarget->IsAlive())
	{
		SetOverMark();
		return;
	}

	unsigned int uHandCardNum = 0;
	unsigned int uDataCnt = pMsg->dataCnt;
	unsigned int uCardCnt = pMsg->cardCnt;
	SeatIdList listCardId;
	for (unsigned int i = 0; i < pMsg->dataCnt && i < MsgMoveCard::sc_max_data_cnt; ++i)
	{
		listCardId.push_back(pMsg->data[i]);
	}
	if (listCardId.size() != pMsg->dataCnt)
	{
		return;
	}

	// 界限检查：选中牌数大于限制牌数
	if (uCardCnt > discard_count)
	{
		APPLOG_ERROR("uCardCnt:" << uCardCnt << " > pRole->GetHandCardSize() :" << pRole->GetHandCardSize() << FUN_FILE_LINE);
		return;
	}

	// 如果仅有1张的情况 则这张卡判断是否为0 如果为0
	if (uCardCnt == 1 && uDataCnt == 1)
	{
		if (listCardId.front() == 0)
		{
			uDataCnt = 0;
		}
	}

	if (uDataCnt > uCardCnt)
	{
		APPLOG_ERROR("uDataCnt" << uDataCnt << "  > uCardCnt:" << uCardCnt << FUN_FILE_LINE);
		return;
	}
	else
	{
		uHandCardNum = uCardCnt - uDataCnt;
	}

	// 界限检查：选中牌数大于目标牌数
	if (uCardCnt > pTarget->GetMyPlayCardCount())
	{
		APPLOG_ERROR("uCardCnt:" << uCardCnt << " > pTarget->GetMyPlayCardCount() :" << pTarget->GetMyPlayCardCount() << FUN_FILE_LINE);
		return;
	}

	std::set<unsigned int> setCard;
	PPlayCardList handCardList;
	PPlayCardList euipCardList;
	for (unsigned int i = 0; i < pMsg->dataCnt && i < MsgMoveCard::sc_max_data_cnt; ++i)
	{
		unsigned int uCardId = pMsg->data[i];
		CPlayCard* pCard = pTarget->GetMyPlayCard(uCardId);
		if (!pCard || !pCard->GetZone())
		{
			continue;
		}
		if (setCard.count(uCardId) > 0)
		{
			return;
		}
		// 检测如果是手牌则错误
		if (pCard->GetZone()->GetZoneType() == ZONE_HAND)
		{
			return;
		}
		euipCardList.push_back(pCard);
		setCard.insert(uCardId);
	}

	if (setCard.size() != uDataCnt)
	{
		return;
	}

	// 判断是否还有手牌
	if (uHandCardNum > 0 && pTarget->GetHandCardZone())
	{
		if (uHandCardNum > pTarget->GetHandCardSize())
		{
			// 拷贝一份
			handCardList = pTarget->GetHandCardZone()->GetPlayCardList();
		}
		else 
		{
			// 拷贝一份
			PPlayCardList tempHandCardList = pTarget->GetHandCardZone()->GetPlayCardList();
			std::random_shuffle(tempHandCardList.begin(), tempHandCardList.end());
			for (unsigned int i = 0; i < tempHandCardList.size() && i < uHandCardNum; ++i)
			{
				handCardList.push_back(tempHandCardList[i]);
			}
		}
	}

	SeatIdList ntfSeatList;
	GetGame()->GetRoleSeatIdListAll(ntfSeatList, false);

	CMoveCardAction* pMoveAc = nullptr;
	if (!handCardList.empty())
	{
		pMoveAc = CMoveCardAction::MoveCardsEx(GetGame(), EmActMode::Mode_DisCard, handCardList, ntfSeatList,
			GetCaster()->GetSeatId(), GetCaster(), SpellId(), &GetGame()->GetDiscardZone());
		if (!pMoveAc)
		{
			APPLOG_ERROR_GAME_LOGIC("CMoveCardAction pAc = null" << FUN_FILE_LINE);
		}
	}

	if (!euipCardList.empty())
	{
		if (pMoveAc)
		{
			if (!pMoveAc->AddMoveCards(EmActMode::Mode_DisCard, GetCaster(), euipCardList, pTarget->GetEquipCardZone(), &GetGame()->GetDiscardZone(), ntfSeatList))
			{
				APPLOG_ERROR_GAME_LOGIC("error move" << FUN_FILE_LINE);
			}
		}
		else
		{
			pMoveAc = CMoveCardAction::MoveCardsEx(GetGame(), EmActMode::Mode_DisCard, euipCardList, ntfSeatList,
				GetCaster()->GetSeatId(), GetCaster(), SpellId(), &GetGame()->GetDiscardZone());
			if (!pMoveAc)
			{
				APPLOG_ERROR_GAME_LOGIC("CMoveCardAction pAc = null" << FUN_FILE_LINE);
			}
		}
	}
	ClearAllOfWaitingOpt();
	SetResolveStep(step_end);
}
```

# 编写指南

## 命名习惯
### 肉鸽
```cpp
Roguelike_JiuChi//类名
SKILL_ROGUELIKE_BUFF_JIUCHI//技能注册ID
class Roguelike_JiuChi : public CSubstituteSpell, public CreateXSpell < Roguelike_JiuChi, (unsigned int)YOKA_SKILL::SKILL_ROGUELIKE_BUFF_JIUCHI >
```

### 比赛
```cpp
ShanJia_XinSha//类名
SKILL_CHARACTER_SFMATCH_SHAN_JIA//技能注册ID
class ShanJia_XinSha : public CSpell, public CreateXSpell<ShanJia_XinSha, (unsigned int)YOKA_SKILL::SKILL_CHARACTER_SFMATCH_SHAN_JIA>
```

### 宏注册DATA,STATE
```cpp
REGISTER_SPELL_DATA_CREATE(ID_RTS_SKILL_ROGUELIKE_BUFF_LIEJIE, Roguelike_LieJieData)

REGISTER_SPELL_STATE_CREATE(ID_RTS_SKILL_CHARACTER_SFMATCH_SHAN_JIA, ShanJiaState_XinSha);

static bool __b_reg_rouge_yi_jue_1 = CSpellMgr::single()->RegisterCanNotPlayCardFun( (unsigned int)YOKA_SKILL::SKILL_ROGUELIKE_BUFF_YIJUE,boost::bind(&Roguelike_YiJue::EffectCanNotPlayCard,_1,_2,_3,_4));
static bool __b_reg_rouge_yi_jue_2 = CSpellMgr::single()->RegistercanNotUsePlayCardFun( (unsigned int)YOKA_SKILL::SKILL_ROGUELIKE_BUFF_YIJUE,boost::bind(&Roguelike_YiJue::EffectCanNotUseCard,_1,_2));
static bool __b_reg_rouge_yi_jue_3 = CSpellMgr::single()->RegisterForbiddenSpellFun( (unsigned int)YOKA_SKILL::SKILL_ROGUELIKE_BUFF_YIJUE,boost::bind(&Roguelike_YiJue::EffectForbiddenCharacterSpell,_1,_2));
```

## 测试
- 日志
.\vc9bin\Server\Logiclogdir\GsLog_43000_2024-12-18_13.40.28_1.log

- 被动
与前端无交互，直接测试对应时机

- 附体
与前端有交互，放在原技能上测试，先暂时交换两个技能id，之后再改回去

- 临时
与前端有交互，后端临时手动命令，扮演处理交互的角色

- 账号
1
4
10
113
changpu

## 合并
1. 主从分支update最新
1. 缺少代码内容的，后上传的，需要更新的，分支，开始merge
1. 选择要合并的另一个分支，showlog，合并
1. 缺少代码内容的，后上传的，需要更新的，分支，commit

## 注意
1. void NetMsgXXX等函数弃用，更换为eSpellCastResult NetMsgXXX
1. 追加写时，转移代码时关注头文件

## 上传
- add
[add][OLH5-80956]新增赛事飞扬

- add
[add][OLH5-80599,OLH5-79825]6药理战法,冲阵/列侯超时逻辑优化

- mod
[mod][OLH5-79682]潜袭战功

- mod
[mod][OLH5-79310,OLH5-79682]潜袭兼容虚拟转化牌,潜袭战功

- mod
[mod][OLH5-79823]镇军削弱新做

- mod
[mod][OLH5-79676]修复父魂战功不触发

- mod
[mod][OLH5-77881,OLH5-77879] 狼袭苦肉修正配置载入

- mod
[mod][OLH5-77879] 苦肉优化弃牌检查

- mod
[mod][OLH5-79823]更正编译匹配错误

- mod
[mod][OLH5-79676]父魂战功

- add
[add][OLH5-79823,OLH5-79825]肉鸽技能组22个

- mod
[mod][OLH5-79676,OLH5-79682]潜袭父魂战功修正category

- mod
[mod][OLH5-80324,OLH5-80335]父魂不询问八卦阵；咆哮失去技能后清除，新老父魂不清除标记原因均来自咆哮

- mod
[mod][OLH5-80324]父魂,装备牌转化杀

- mod
[mod][OLH5-79304]父魂,优化转化杀响应逻辑

- mod
[mod][OLH5-79682]潜袭战功

- add
[add][OLH5-79676,OLH5-79682]潜袭战功,父魂战功

- add
[add][OLH5-79310,OLH5-79676,OLH5-79682]潜袭,潜袭战功,父魂战功

- mod
[mod][OLH5-79304]父魂,修复虚拟杀上标记问题

- mod
[mod][OLH5-79304]父魂,检测flag不阻止闪进行

- mod
[mod][OLH5-79304]父魂,虚拟杀排除

- mod
[mod][OLH5-79304]父魂,埋祸空指针检查

- mod
[mod][OLH5-79304]shan头文件

- mod
[mod][OLH5-79304]父魂头文件

- add
[add][OLH5-79304]界关兴张苞父魂 

- mod
[mod][OLH5-78301] 修复怀异限制次数错误

- mod
[mod][OLH5-78301] 怀异增加展示时间

- mod
[mod][OLH5-78301] 怀异修复：前端请求获取牌失败

- mod
[mod][OLH5-78302] 缮甲修复：弃牌显示超出限制

- mod
[mod][OLH5-78300] 趫猛弃用旧函数

- add
[add][OLH5-78301] 怀异

- mod
[mod][OLH5-78302,OLH5-78309] 缮甲奋音data宏注册

- mod
[mod][OLH5-78300] 趫猛修复超时逻辑

- add
[add][OLH5-78300,OLH5-78302,OLH5-78309] 义从趫猛缮甲奋音

- mod
[mod][OLH5-77881] 狼袭载入配置

- mod
[mod][OLH5-77881] 狼袭优化,自动适配上下限配置

- mod
[mod][OLH5-77879] 苦肉优化弃牌检查

- mod
[mod][OLH5-77881,OLH5-77889] 神戟方天叠加计算，狼袭时机处理

- add
[add][OLH5-77879,OLH5-77880,OLH5-77881,OLH5-77888,OLH5-77889,OLH5-77890] 苦肉破军狼袭神威神戟神躯

## 联调
潜袭曹书源
父魂凌鹏远

- XSY
渐营
恃才
弓骑
甘露
制衡
英姿
烈节
援资
狞恶
镇军
突袭

- 李艺飞
武烈✔️
英魂✔️
笃烈✔️
义绝✔️
除疠✔️
冲阵❎
列侯✔️
醇醪✔️
弘德✔️
实荐✔️
誉虚✔️

苦肉XSY✔️
破军XSY✔️
狼袭WYW✔️
神威WYW✔️
神戟WYW✔️
神躯LXH✔️
修罗LXH✔️

义从XSY✔️
趫猛XSY✔️
奋音XSY✔️
缮甲WYW✔️
怀异WYW✔️

## 策划
技能X上限
两个选项差距是否太大
递增数量从0还是1开始
使用是否包含打出
## 配置
技能配置：Develop\server_xml\cha_spellextend.xml
肉鸽技能配置：Develop\server_xml\hd_roguelike.xml
战功：Develop\服务端更新\xmlconfig\gn_gs_ahievement.xml

```cpp
//Resolve
//获取配置
auto* spellExtend = CCardDataRepository::Singleton(GAME_START_TIME)->GetActivitySpellExtendData(GetGame()->GetLabelModel(), GetSpellId(), GetGame()->GetDifficultId());
unsigned int use_time = 3;
if (spellExtend && spellExtend->pra1 > 0)
{
	use_time = spellExtend->pra1;
}

//CanCast
//获取配置
auto* spellExtend = CCardDataRepository::Singleton(pGame->GetGameStartTime())->GetActivitySpellExtendData(pGame->GetLabelModel(), SpellId(), pGame->GetDifficultId());
unsigned int use_time = 3;
if (spellExtend && spellExtend->pra1 > 0)
{
	use_time = spellExtend->pra1;
}

//获取配置已弃用
const CCardSpellExtendData*pSpellExData = CCardDataRepository::Singleton(GAME_START_TIME)->GetSpellExtendData(SpellId());
const CCardSpellExtendData* pSpellExData = CCardDataRepository::Singleton(pGame->GetGameStartTime())->GetSpellExtendData(SpellId());
unsigned int spell_time_limit = 3;
if (pSpellExData)
{
    spell_time_limit = pSpellExData->getParam(0);
}
else
{
    APPLOG_ERROR_GAME_LOGIC("KuRou spell config error:spell_time_limit" << FUN_FILE_LINE);
}
```
## 前端
### log
1. F12
1. 清除历史记录
1. 搜索技能id
1. 发送协议

### 备注
前端param是uint，msg.param = m_src_discard_count
前端params是数组，msg.datas[msg.dataCnt++] = m_type_count

### StoC
```cpp
//选择协议
AskClient(msg)
Broadcast(&msg)
MsgRoleOptTargetNtf//21215
MsgRoleSpellOptRep//21220双向

//使用技能
BroadcastSpellOptMsg()
MsgUseSpell
PUB_GS_C_USE_SPELL=21212双向

//通知数据
MsgRoleSpellOptRep
C_GS_ROLE_SPELL_OPT_REP=21220双向

//请求响应
AskClientResponseSpell()
MsgRoleOptTargetNtf
GS_C_ROLE_OPT_TARGET_NTF=21215

//更新数据
AddSpellUseTimes()
UpateDataToClient()，UpdateRoleData_Ex()
MsgUpdateRoleData_Ex_Ntf
GS_C_UPDATE_ROLE_DATA_EX_NTF=21252
```

### CtoS
```cpp
action.h
virtual eSpellCastResult NetMsgMoveCardRpyResult(const MsgMoveCard* pMsg, CGsUser* pUser);//21209
virtual eSpellCastResult NetMsgUseCardRpyResult(const MsgUseCard* pMsg, CGsUser* pUser);//21210
virtual eSpellCastResult NetMsgUseSpellRpyResult(const MsgUseSpell* pMsg, CGsUser* pUser);//21212双向
virtual eSpellCastResult NetMsgCancelRpyResult(const MsgClientRoleOptRep* pMsg, CGsUser* pUser);//21219
virtual eSpellCastResult NetMsgRoleSpellOptRpyResult(const MsgRoleSpellOptRep* pMsg, CGsUser* pUser);//21220双向

// 客户端操作转发
virtual void NetMsgClientOperateInGameNtf(const MsgClientOperateInGameNtf* pMsg, CGsUser* pUser);//21261
```

### 总结
12BroadcastSpellOptMsg()
15AskClientResponseSpell()
52UpateDataToClient()，UpdateRoleData_Ex()

09NetMsgMoveCardRpyResult()
10NetMsgUseCardRpyResult()
12NetMsgUseSpellRpyResult()
19NetMsgCancelRpyResult()
20NetMsgRoleSpellOptRpyResult()---MsgRoleSpellOptRep

61NetMsgClientOperateInGameNtf()//CtoS

## 战功模板
- 代码
```cpp
CGsUser* pGsUser = GetGame()->FindGsUserbySeatId(GetCasterSeatId());
if (pGsUser == NULL )
{
    return;
}
AchEvent achEvent(ACHIEVEMENT_EVENT_SPECIAL_SPELL_EFFECT, GetCaster(), nullptr, nullptr);
achEvent.param1 = GetSpellId();
achEvent.param2 = GetUseCardColor();
g_fun_event_ach(pGsUser, achEvent, 1);
```

- 常规
```xml
<!--
AchievementCommonDefine.h
1. Achievement
Id：策划文档-战功
category：包+势力。例如界一将+蜀=16+2^26=67108880
flags：emAchievementFlags客户端显示的类型，1024为武将技能，2048为百胜

2. CriteriaEntry
Id：顺延
count：战功条件的数值
flag：4为武将技能，0为百胜

3. Event
eventType：事件类型
ACHIEVEMENT_EVENT_SPECIAL_SPELL_EFFECT=78,//技能效果选择

type：一般为0，游戏结束重置为1
value1：界限比较的数值
compare1：界限比较的符号
	NOT_EQUAL					= 0,//不相等，不是, 没有
	EQUAL						= 1,		  //相等，是, 有
	GREATER_THEN				= 2,//大于
	GREATER_THEN_OR_EQUAL		= 3,//大于等于
	LESS_THEN					= 4,//小于
	LESS_THEN_OR_EQUAL			= 5,//小于等于
	AND_OPERATION				= 6,//与运算

-->
<Achievement Id="1305" category="67108880" point="5"  unlockAchievement="0" unlockLevel="0" characterId="690" figure="0" gameMode="2" flags="1024" desc="使用界关兴张苞在一局游戏中通过父魂使用两种颜色的转化杀。" requirementCount="0">
    <CriteriaEntry Id="1823" count="1" flag="4" desc="父魂使用红色杀">
        <Event eventType="78" type="0" compare1="1" value1="3651" compare2="1" value2="1" recordSeatType="2">
        </Event>
        <Event eventType="1" type="1">游戏开始
        </Event>
        <Event eventType="2" type="1">游戏结束
        </Event>
    </CriteriaEntry>
    <CriteriaEntry Id="1824" count="1" flag="4" desc="父魂使用黑色杀">
        <Event eventType="78" type="0" compare1="1" value1="3651" compare2="1" value2="2" recordSeatType="2">
        </Event>
        <Event eventType="1" type="1">游戏开始
        </Event>
        <Event eventType="2" type="1">游戏结束
        </Event>
    </CriteriaEntry>
</Achievement>

```

- 胜利
```xml
<!--value1为上一个条件-->
</CriteriaEntry>
    	<CriteriaEntry Id="1759" count="1" flag="4">游戏胜利 
        	<Event eventType="4" type="0">胜利
			<And>
				<Condition conditionType="21" compare1="1" value1="1758"/>
			</And>
      	</Event>
    	</CriteriaEntry>
```

- 势力
```xml
<!--enum emAchUICategory-->
emAchUICategory_Wei		= ( 1 << 3),	// 魏 8
emAchUICategory_Shu		= ( 1 << 4),	// 蜀 16
emAchUICategory_Wu		= ( 1 << 5),	// 吴 32
emAchUICategory_Qun		= ( 1 << 6),	// 群 64
emAchUICategory_JX_YJ		= (1 << 26),	// 界一将2^26=67108864

```

## 技能模板
- H
技能效果：A，B
技能流程：A1，A2
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机
    - `role.h`注册标记牌区域，`role.cpp`设置标记牌可见属性
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
- Data
- State
●StoC

●CtoS
- TimeOutCallBack
- X
- TEST

# 示例技能3

## 药理
每回合限Y次，回复体力时，额外回复x点
- H
技能效果：A，B
技能流程：A1，A2
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_ROGUELIKE_YAO_LI_JING_TONG3 = 13314,  //药理精通1-1
SKILL_ROGUELIKE_YAO_LI_JING_TONG4 = 13315,  //药理精通1-3
SKILL_ROGUELIKE_YAO_LI_JING_TONG5 = 13316,  //药理精通2-1
SKILL_ROGUELIKE_YAO_LI_JING_TONG6 = 13317,  //药理精通2-3
SKILL_ROGUELIKE_YAO_LI_JING_TONG = 13179, //药理精通·壹
SKILL_ROGUELIKE_YAO_LI_JING_TONG2 = 13180, //药理精通·贰
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机
    - `role.h`注册标记牌区域，`role.cpp`设置标记牌可见属性
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
- Data
- State
●StoC

●CtoS
- TimeOutCallBack
- X
- TEST✔️❎
玩家：13179；13180；13314；13315；13316；13317
对手：

回复体力4次-OK✔
回合外回复体力-OK✔
下回合回复体力-OK✔

## 飞扬
地主判定阶段开始时，你可以弃置两张手牌并弃置判定区里的一张牌

- H
技能效果：A，B
技能流程：A1，A2
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_CHARACTER_SFMATCH_FEI_YANG = 21071
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机
    - `role.h`注册标记牌区域，`role.cpp`设置标记牌可见属性
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
- Data
- State
●StoC

●CtoS
- TimeOutCallBack
- X
- TEST✔️❎
玩家：21071 飞扬；371	解围；402 酒诗；1500	萌态；92	闪电；97	乐；144	兵
对手：

弃置牌-只能弃手牌✔
0张判定牌-不呼出✔
1张判定牌-全弃✔
3张判定牌-弃1✔
0张手牌-不呼出✔
1张手牌-不呼出✔
2张手牌-呼出✔
发动2次-OK✔

# 示例技能2

## 武烈
结束阶段限一次，你可以失去任意点体力，令X名其他角色获得“烈”标记（X为以此法失去的体力值）。当有“烈”的角色受到伤害时，其移除“烈”并防止此伤害，然后令你回复1点体力

- H
技能效果：A，B
技能流程：A1，A2
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_ROGUELIKE_BUFF_WULIE = 14111
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机
    - `role.h`注册标记牌区域，`role.cpp`设置标记牌可见属性
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
- Data
- State

- TimeOutCallBack
- X
- TEST
玩家：14111 武烈；306 业炎
对手：
结束阶段发动选择4名已受伤和未受伤角色-获得烈✔️
已受伤烈角色受到伤害-防止，不回复体力，自己回复体力✔️
再次结束阶段发动选择0-1烈的角色-均递增烈✔️【❎1烈角色会消失-有烈的角色不更新状态】

## 英魂
准备阶段，若你已受伤，你可以选择任意名其他角色并选择一项：1.令其摸X张牌，然后弃置一张牌；2.令其摸一张牌，然后弃置X张牌。（X为你已损失体力值）

- H
技能效果：A，B
技能流程：A1，A2
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_ROGUELIKE_BUFF_YINGHUN = 14110
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机
    - `role.h`注册标记牌区域，`role.cpp`设置标记牌可见属性
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
- Data
- State

- TimeOutCallBack
- X
- TEST
玩家：14110 英魂；62 苦肉
对手：
未受伤-不发动✔️
选择自己-无法执行✔️
选择所有其他角色-执行同一项【❎只能选一个人-GetBaseCheck注释目标检测】
选择选项超时-自动选择摸X✔️
选择弃牌超时-自动弃置要求量✔️

## 笃烈
每回合限一次，你成为其他角色基本牌或普通锦囊牌的唯一目标时，你摸X张牌（X为你的攻击范围且至多为5）。

- H
技能效果：A，B
技能流程：A1，A2
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_ROGUELIKE_BUFF_DUBLIE = 14102
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机
    - `role.h`注册标记牌区域，`role.cpp`设置标记牌可见属性
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
- Data
- State

- TimeOutCallBack
- X
- TEST
玩家：14102 笃烈；4308 霹雳车9
对手：

成为杀唯一目标-摸✔️
成为南蛮入侵多目标-不摸✔️
先成为多目标再成为单目标-摸✔️
先成为单目标再成为单目标-摸✔️
攻击范围为1-摸1✔️
攻击范围为3-摸3✔️
攻击范围为9-摸5✔️

## 义绝
出牌阶段限一次，你可以弃置一张牌，然后令一名其他角色展示一张手牌。若此牌为：黑色，其本回合非锁定技失效且不能使用或打出手牌，你本回合对其使用的红桃【杀】伤害+3X；红色，你获得之，然后你可以令其回复0Y点体力。
3	0

- H
技能效果：A，B
技能流程：A1，A2
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_ROGUELIKE_BUFF_YIJUE = 14205
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机
    - `role.h`注册标记牌区域，`role.cpp`设置标记牌可见属性
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
- Data
- State

- TimeOutCallBack
- X
- TEST
玩家：14205 义绝；
对手：

展示黑-使用红桃杀+3✔️
展示红-获得回复0✔️
展示红-获得不回复✔️

## 除疠
出牌阶段限三次，你可以选择任意名势力各不相同的其他角色，弃置你和这些角色的各一张牌，然后被弃置黑桃牌的角色各摸一张牌。

- H
技能效果：A，B
技能流程：A1，A2
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_ROGUELIKE_BUFF_CHULI = 14202
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机
    - `role.h`注册标记牌区域，`role.cpp`设置标记牌可见属性
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
- Data
- State

- TimeOutCallBack
- X
- TEST
玩家：14202 除疠；
对手：

使用3次技能-✔️

## 冲阵
当你发动“龙胆”时，你可以获得对方的两X张手牌。

- H
技能效果：A，B
技能流程：A1，A2
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_ROGUELIKE_BUFF_CHONGZHEN = 14197
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机
    - `role.h`注册标记牌区域，`role.cpp`设置标记牌可见属性
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
●StoC
15AskClientResponseSpell，座位
pParam->targets.push_back(uTargetSeatId);
数量不传，走配置，2张
●CtoS
09NetMsgMoveCardRpy
- Data
- State

- TimeOutCallBack
- X
- TEST✔️❎
玩家：14197 冲阵；37	龙胆
对手：

超时-拿2，不足拿全部✔️

使用转化杀-拿2✔️
使用转化闪-拿2✔️

## 列侯
出牌阶段限一次，你可以令你攻击范围内一名有手牌的角色交给你所有手牌，若如此做，你将一半手牌交给其。

- H
技能效果：A，B
技能流程：A1，A2
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_ROGUELIKE_BUFF_LIEHOU = 14173
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机
    - `role.h`注册标记牌区域remove_type_chun_rogue，`role.cpp`设置标记牌可见属性
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
15AskClientResponseSpell()，请求选择一半手牌，param(nCount + 1) / 2
NetMsgRoleSpellOptRpy()，交出一半手牌

- Data
- State

- TimeOutCallBack
- X
- TEST
玩家：14173 列侯；31	仁德；209 离魂
对手：
给出鸡肋牌-❎做了多余的弃牌检查✔️

攻击范围外-无法选中✔️
手牌为0-无法选中✔️
拿后6-给3✔️
拿后5-给3✔️
0拿1-给1✔️
## 醇醪
你或你相邻角色的【杀】因弃置置入弃牌堆后，将之置于你的武将牌上，称为“醇”。当一名角色处于濒死状态时，你可以移去1X张“醇”视为其使用一张【酒】

- H
技能效果：A，B
技能流程：A1，A2
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_ROGUELIKE_BUFF_CHUNLAO = 14159
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机
    - `role.h`注册标记牌区域remove_type_chun_rogue，`role.cpp`设置标记牌可见属性
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
- Data
- State

- TimeOutCallBack
- X
- TEST
玩家：14159 醇醪
对手：

消耗1-使用酒✔️
再次消耗1-使用酒✔️

## 弘德
当你一次获得至少两张手牌或失去至少一X张牌后，你可以令一名其他角色摸两Y张牌。
1	2

- H
技能效果：A，B
技能流程：A1，A2
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_ROGUELIKE_BUFF_HONGDE = 14108
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机
    - `role.h`注册标记牌区域，`role.cpp`设置标记牌可见属性
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
- Data
- State

- TimeOutCallBack
- X
- TEST
玩家：14108 弘德
对手：

获得2-给摸2✔️
失去1-给摸2✔️
使用装备-给摸2✔️
选自己-无法选中✔️
## 实荐
当其他角色于其回合内使用第二张牌后，你可以令其于本回合获得“誉虚”。

- H
技能效果：A，B
技能流程：A1，A2
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_ROGUELIKE_BUFF_SHIJIAN = 14107
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机
    - `role.h`注册标记牌区域，`role.cpp`设置标记牌可见属性
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
- Data
- State

- TimeOutCallBack
- X
- TEST
玩家：14107 实荐
对手：

使用2-给技能✔️
使用3-不能给✔️

## 誉虚
当你于出牌阶段使用牌后，你可以摸两X张牌，若如此做，当你本阶段使用下一张牌后，你不能以此法摸牌且须弃置一张牌。

- H
技能效果：A，B
技能流程：A1，A2
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_ROGUELIKE_BUFF_YUXU = 14106
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机Opp_after_use_card
    - `role.h`注册标记牌区域，`role.cpp`设置标记牌可见属性
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
- Data
- State

- TimeOutCallBack
- X
- TEST
玩家：14106 誉虚
对手：

使用1-摸2✔️
使用2-弃1✔️

## 突袭
摸牌阶段，你可以少摸任意张牌并获得等量其他角色的各X张手牌。（X为你当前体力值）

- H
技能效果：A，B
技能流程：A1，A2
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_ROGUELIKE_BUFF_TUXI = 14134
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机
    - `role.h`注册标记牌区域，`role.cpp`设置标记牌可见属性
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
AskClientResponseSpell，msg.param=体力值
- Data
- State
●StoC
15请求-拿牌
opttype=OPT_SEL_CARD_HAND//3
param=GetCaster()->GetCurHp()//体力值
●CtoS
09确认-拿牌

- TimeOutCallBack
- X
- TEST✔❎
玩家：14134 突袭
对手：
少摸1-拿X摸1✔
拿大于体力值-手动✔
拿小于体力值-自动✔
拿大于体力值和大于体力值-手动✔
拿小于体力值和大于体力值-手动✔
拿大于体力值和小于体力值-手动✔
拿大于体力值超时-自动✔

## 镇军
准备阶段，你可以弃置一名角色X张牌（X为其手牌数减体力值且至少为1），然后选择一项：1.你摸与其中非装备牌数等量张牌；2.其受到与其中非装备牌数等量伤害。

准备阶段，你可以弃置一名角色X张牌（X为其手牌数减体力值且至少为1），然后选择一项：1.你摸与其中非装备牌数等量张牌；2.其受到与其中牌包含类别等量伤害。

- H
技能效果：A，B
技能流程：A1，A2
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_ROGUELIKE_BUFF_ZHENJUN = 14137
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机
    - `role.h`注册标记牌区域，`role.cpp`设置标记牌可见属性
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
●StoC
21215请求-弃对方牌
param=m_discard_count//弃牌的数量

21215请求-选择分支效果
msg.optType = 28;
msg.param = m_src_discard_count;//伤害值

●CtoS
21219取消-不造成伤害，直接摸牌

21220确认-选择分支效果-弃牌或造成伤害
原技能摸牌的逻辑弃用

- Data
- State

- TimeOutCallBack
- X
- TEST✔❎
玩家：14137 镇军
对手：
弃置装备X为0-结束✔
弃置手牌X为1，选确定-摸牌✔
弃置手牌X为1，选取消-伤害✔
弃置手牌X为1，等超时-伤害✔
弃置自己装备X为0-结束✔
弃置自己手牌X为1，选确定-摸牌✔
弃置自己手牌X为1，选取消-伤害✔
弃置自己手牌X为1，等超时-伤害✔

## 狞恶
锁定技，当一名角色每回合第二次受到伤害后，若其为你或伤害来源为你，你摸X张牌并弃置其场上一张牌。(X为本局此技能发动次数，至多为5）

- H
技能效果：A，B
技能流程：A1，A2
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_ROGUELIKE_BUFF_NINGE = 14140
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机
    - `role.h`注册标记牌区域，`role.cpp`设置标记牌可见属性
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
21215（OPT_COMMON_2=29）请求弃置牌

21209接收
- Data
- State

- TimeOutCallBack
- X
- TEST✔❎
玩家：14140 狞恶
对手：
触发-第二次受到伤害✔
回合内连续触发到3-摸3张牌✔
每回合触发一次到3-摸3张牌✔

## 援资
每轮限一次，其他角色的准备阶段，你可以交给其所有手牌。若如此做，当其本回合造成伤害后，你可以摸X张牌。（X为场上存活人数）

- H
技能效果：A，B
技能流程：A1，A2
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_ROGUELIKE_BUFF_YUANZI = 14141
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机
    - `role.h`注册标记牌区域，`role.cpp`设置标记牌可见属性
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
- Data
- State
21252更新状态
- TimeOutCallBack
- X
- TEST✔❎
玩家：14141 援资
对手：
摸牌-场上存活人数✔

## 烈节
当你受到伤害后，你可以弃置至多八张牌并摸等量张牌，然后你可以弃置伤害来源至多X张牌（X为你以此法弃置的红色牌数）。

- H
技能效果：A，B
技能流程：A1，A2
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_ROGUELIKE_BUFF_LIEJIE = 14142
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机
    - `role.h`注册标记牌区域，`role.cpp`设置标记牌可见属性
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
- Data
- State

- TimeOutCallBack
- X
- TEST

## 英姿
锁定技，摸牌阶段，你多摸X张牌。你的手牌上限为你的体力上限。（X为场上存活人数）

- H
技能效果：A，B
技能流程：A1，A2
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_ROGUELIKE_BUFF_YINGZI = 14146
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机
    - `role.h`注册标记牌区域，`role.cpp`设置标记牌可见属性
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
- Data
- State

- TimeOutCallBack
- X
```
//spellMgr.cpp
if (rRole.HasCharacterSpell( (unsigned int)YOKA_SKILL::SKILL_ROGUELIKE_BUFF_YINGZI))//英姿.肉鸽
		return rRole.GetMaxHp();
```
- TEST✔️❎
玩家：14146 英姿
对手：

开局-多摸8✔️

## 制衡
出牌阶段限X三次，你可以弃置任意张牌，然后摸等量张牌，若你以此法弃置了所有手牌，你额外摸一张牌。

- H
技能效果：A，B
技能流程：A1，A2
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_ROGUELIKE_BUFF_ZHIHENG = 14149
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机
    - `role.h`注册标记牌区域，`role.cpp`设置标记牌可见属性
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
- Data
- State

- TimeOutCallBack
- X
- TEST✔️❎
玩家：14149 制衡
对手：

发动次数-3✔️
全制衡-多摸1✔️
不全制衡-不多摸✔️

## 甘露
出牌阶段限一次，你可以令两名角色交换装备区里的牌。

- H
技能效果：A，B
技能流程：A1，A2
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_ROGUELIKE_BUFF_GANLU = 14156
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机
    - `role.h`注册标记牌区域，`role.cpp`设置标记牌可见属性
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
- Data
- State

- TimeOutCallBack
- X
- TEST✔️❎
玩家：14156 甘露
对手：

都没装备-不交换✔️
一方有装备-交换✔️

## 弓骑
出牌阶段限一次，你可以弃置一张牌令你本回合攻击范围无限，然后你可以弃置一名其他角色X张牌。（X为你与其计算距离）

- H
技能效果：A，B
技能流程：A1，A2
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_ROGUELIKE_GONG_QI = 14160
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机
    - `role.h`注册标记牌区域，`role.cpp`设置标记牌可见属性
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
21215请求弃牌；OPT_COMMON_1=28；参数：param=弃牌数（配置）
21220通知数据；参数：msg.data为弃牌座位ID

- Data
- State

- TimeOutCallBack
- X
```cpp
//spellMgr.cpp
uRet += Roguelike_GongQi::AddAttRange(pRole, pRole);

if (Roguelike_GongQi::AddAttRange(pRole, pRole) > 0){
		return true;
	}
```
- TEST✔❎
玩家：14160 弓骑
对手：
弃置自己牌-✔
弃置其他角色牌-距离张数✔

## 恃才
当你每回合首次使用一个点数的牌后，你可以将之置于牌堆顶，然后摸一张牌。

- H
技能效果：A，B
技能流程：A1，A2
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_ROGUELIKE_SHI_CAI = 14163
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机
    - `role.h`注册标记牌区域，`role.cpp`设置标记牌可见属性
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
- Data
- State

- TimeOutCallBack
- X
- TEST✔️❎
玩家：14163 恃才；816	寸目
对手：

使用新点数-摸牌✔️
使用重复点数-不摸牌✔️
使用单转化牌-摸牌✔️
使用双转化牌-不摸牌✔️
使用虚拟牌-不摸牌✔️

## 渐营
当你于出牌阶段使用牌时，若此牌的点数或颜色与你本阶段使用的上一张牌相同，你可以摸两张牌。
- H
技能效果：A，B
技能流程：A1，A2
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_ROGUELIKE_JIAN_YING = 14164
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机
    - `role.h`注册标记牌区域，`role.cpp`设置标记牌可见属性
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
- Data
- State

- TimeOutCallBack
- X
- TEST
使用红+红-1✔️
使用红+黑-0✔️
转化使用红+红-1❎
转化使用红+黑-0❎
使用红+无色+红-11✔️
使用红+无色+黑-11✔️
使用无色+无色+无色-11✔️

## 潜袭
准备阶段，你可以摸一张牌并展示一张牌。若如此做，距离为1的其他角色本回合不能使用或打出与“潜袭”牌颜色相同的手牌，你本回合使用“潜袭”牌造成的伤害+1。

使用界马岱在一局游戏中使用潜袭牌杀死一名角色并获胜。
- H
技能效果：A，B
技能流程：A1，A2
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_CHARACTER_QIAN_XI_PO = 3663
    - 注册技能类型`REGISTER_TRIGGER_AND_CASTAS_SPELL`
    - `trigger_action.cpp`注册时机Opp_Cause_Damage
    
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
21220MsgRoleSpellOptRep-Broadcast()：距离合法的所有座位msg.data[msg.dataCnt] = pTempRole->GetSeatId();
21252UpateDataToClient()：潜袭牌标记的增减。潜袭牌颜色

- Data
- State
- TimeOutCallBack
- X
```
static bool __b_reg3_new = CSpellMgr::single()->RegisterCanNotPlayCardFun( (unsigned int)YOKA_SKILL::SKILL_CHARACTER_QIAN_XI_PO,boost::bind(&QianXiJ::CanNotPlayCard,_1,_2,_3,_4));
static bool __b_reg4_new = CSpellMgr::single()->RegistercanNotUsePlayCardFun( (unsigned int)YOKA_SKILL::SKILL_CHARACTER_QIAN_XI_PO,boost::bind(&QianXiJ::CanNotUseCard,_1,_2));
```
- TEST
玩家：696-3663 潜袭；33武圣；374	伏骑；62	苦肉
对手：46 倾国；800 卫境；138	断肠；885	缠怨

战功✔
潜袭+断肠✔
❎CanRemove增加失去技能标记
潜袭+卫境✔
❎自己也有状态，使用虚拟或转化后，进入潜袭可用牌函数被禁止使用
——————————————————————
展示1手牌✔
展示超时-随机1✔

展示红-能黑闪，不能红闪，能虚拟闪✔
二度进回合展示黑-不能黑闪，能红闪，能虚拟闪✔

-1马，有多个目标-封多人，加伤有效✔
敌方+1马，0目标-封0人，加伤有效✔

潜袭牌伤害-+1✔
潜袭牌铁索传导-不递增✔

潜袭牌【武圣】当杀-加伤✔
潜袭牌进入装备区，【武圣】当杀-加伤无效✔
潜袭牌下回合使用-加伤无效✔

潜袭+缠怨，目前的牌局表现，符合同类技能的表现。这些技能有以下的共同点：给牌上标记，在技能失效时，延时的状态存在，瞬时的技能效果不存在。例如：
875	洛神	准备阶段，你可以判定，若结果为黑色，你获得此牌，然后你可以重复此流程。以此法获得的牌本回合不计入手牌上限。

3407	重身	你本轮获得的牌可当【闪】使用。

3491	酒诗	你可以将武将牌翻至背面，视为使用一张【酒】，当你的武将牌背面朝上时，你使用的“落英”牌无视距离限制且无法被响应。当你受到伤害或者回合外累计获得至少X张“落英”牌后（X为你体力值上限），若你的武将牌背面朝上，你可以翻至正面。

截图中，缠怨后标记均未消失，但是重身不能发挥瞬时的技能效果：当【闪】使用
## 父魂
FuHunJ
你可将两张牌当【杀】使用或打出。你使用的转化【杀】目标角色只能使用颜色相同的手牌响应；你于出牌阶段使用【杀】造成伤害后，你本回合获得“武圣”“咆哮”。

使用界关兴张苞在一局游戏中通过父魂使用两种颜色的转化杀。
- H
技能效果：A转化，B转化效果，C获得技能
技能流程：A1，A2
- CONST
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能
    - 注册技能类型`REGISTER_TRIGGER_AND_CASTAS_SPELL`
    - `trigger_action.cpp`注册时机Opp_Cause_Damage
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
1. A1
2. A2
- NetMsg
颜色：pParam->paramList
- Data
- State
- TimeOutCallBack
- X
```cpp
//shan.cpp
eSpellCastResult fuhunj = FuHunJ::CanCastUseShan(pgame, pparam);
if (SPELL_CAST_OK != fuhunj)
    return fuhunj;
```
- TEST
玩家：3651 父魂
对手：46 倾国；800 卫境

父魂转化手牌+装备区-使用✔️
父魂转化装备区+装备区-打出✔️

父魂转化红色杀-不能黑闪，能红闪，不能虚拟闪✔️
父魂转化黑色杀-能黑闪，不能红闪，不能虚拟闪✔️
父魂转化无色杀-都不能闪✔️

丈八转化红色杀-不能黑闪，能红闪，不能虚拟闪✔️
丈八转化黑色杀-能黑闪，不能红闪，不能虚拟闪✔️
丈八转化无色杀-都不能闪✔️
武圣转化红色杀-不能黑闪，能红闪，不能虚拟闪✔️

虚拟杀-都能闪✔️
实体非转化杀-都能闪✔️
装备区转化闪-不能闪✔️
木牛流马闪-不能闪✔️

使用杀未造成伤害-不获得技能✔️
使用杀造成伤害-获得技能✔️
使用转化杀未造成伤害-不获得技能✔️
使用转化杀造成伤害-获得技能✔️
回合结束-失去技能✔️

# 示例技能1
## 执笏
锁定技，每回合限两次，当你对其他角色造成伤害后，你摸两张牌。
- H
技能效果：A，B
技能流程：A1，A2
- CONST
摸牌数2
技能使用次数2
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机
- CanTriggerMe
空检查：回合运行状态
空检查：角色存活，角色技能状态管理器【CRole】
空检查：技能数据
界限检查：技能次数限制
条件检查：伤害来源不为自己
- CanCast
若为锁定技，TRUE
- Resolve
行为：摸牌
- NetMsg
- Data
- State
- TimeOutCallBack

## 移荣
出牌阶段限两次，你可以将手牌摸/弃至手牌上限并令你手牌上限-1/+1。

- H
技能效果
effect_dealcard = 1,
effect_discard,
- CONST
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能
    - 注册技能类型`REGISTER_NORMAL_SPELL`
- CanTriggerMe
若为主动技，TRUE
- CanCast
空检查：技能数据【YiRongData】
界限检查：技能次数限制
界限检查：手牌和上限是否相等
匹配检查：能否自己弃置牌
- Resolve
行为：摸牌
行为：弃牌，选中牌依次入栈
修改：额外手牌上限
- NetMsg
- Data
- State
- TimeOutCallBack

## 开济
出牌阶段限一次，你可以令一名本轮未以此法指定过的角色弃置你一张手牌，然后你可以使用弃置的牌，若如此做，你摸一张牌。

- H
技能流程：
step_begin = 0,
step_discard_wait,
step_usecard_wait,
step_deal_card,//摸牌
step_use_card,//用牌
- CONST
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
- CanTriggerMe
若为主动技，TRUE
- CanCast
界限检查：使用次数
- Resolve
匹配检查：牌是否可用
匹配检查：有没有能指定的目标
选择可见手牌/随机手牌
请求client消息
成功失败绑定函数
- NetMsg
NetMsgMoveCardRpy选择弃一张牌
NetMsgUseCardRpyResult使用弃置的牌，杀无视次数
NetMsgCancelRpyResult取消使用弃置的牌
- Data
记录技能选择过的目标，重置技能
- State
- TimeOutCallBack
随机选择弃一张牌

## 垦伤
- H
技能效果：
skill_usecard = 1,转化牌
skill_change_target,改目标
skill_after_sha,摸牌
技能流程：改目标
step_begin = 0,改
step_lost_skill_wait,改动失败
- CONST
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能
    - 注册技能类型`REGISTER_TRIGGER_AND_CASTAS_SPELL`
    - `trigger_action.cpp`注册时机Opp_select_target,Opp_after_sha_resolved
- CanTriggerMe

- CanCast
界限检查：底牌数量
匹配检查：底牌可使用
- Resolve
1. 转化牌
转化牌
2. 改目标
筛选可选中目标列表
重新指定目标列表
3. 摸牌
伤害总值
若以此法
- NetMsg
- Data
- State
- TimeOutCallBack

## 苦肉R
出牌阶段限X次，你可以弃置Y张牌，可以失去1点体力，然后回复Z点体力
3	0		1
- H
技能流程
step_begin = 0,//弃牌
step_lose_hp,//失去体力
step_end//回复体力
- CONST
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_ROGUELIKE_KU_ROU = 14109
    - 注册技能类型`REGISTER_NORMAL_SPELL`
- CanTriggerMe
若为主动技，TRUE
- CanCast
界限检查：濒死
- Resolve
失去体力
回复体力
- NetMsg
- Data
- State
- TimeOutCallBack

## 破军R
当你使用【杀】指定目标后，你可以将其至多X张牌移出游戏直到回合结束（X为其体力值）。你使用的【杀】对手牌区与装备区内牌数皆不大于你的角色造成的伤害+1。
- H
技能效果：
effect_delcard = 1,		// 移除卡
effect_givecard = 2,	// 归还卡
effect_add_damage = 3,	// 增加伤害
技能流程：移除卡
step_begin = 0,
step_wait_movecard,
step_end
- CONST
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机Opp_after_choose_target，Opp_after_turn_end，Opp_When_Cause_Damage
    - `role.h`注册标记牌区域，`role.cpp`设置标记牌可见属性
- CanTriggerMe
1. 移除卡
空检查：杀的目标和来源
2. 归还卡
空检查：特殊牌区
3. 增加伤害
界限检查：牌数量
- CanCast
若为锁定技，TRUE
- Resolve
1. 移除卡
自动选择：一张牌，走超时逻辑
2. 归还卡
给client发消息

- NetMsg
NetMsgMoveCardRpy
选择随机手牌
选择指定装备
- Data
- State
移除状态removeSpellState
- TimeOutCallBack
手牌，装备，各选择一张牌

## 狼袭R
每个人的准备阶段，你可以对一名体力值不大于你的其他角色造成X~Y点随机伤害。
1	2

- H
- CONST
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_ROGUELIKE_LANG_XI = 14113
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机Opp_phase_begin
- CanTriggerMe
- CanCast
界限检查：选择角色数
界限检查：选择角色体力
- Resolve
随机伤害值
- NetMsg
- Data
- State
- TimeOutCallBack

## 义从
锁定技，你计算与其他角色的距离-1；若你已损失的体力值大于等于2，其他角色计算与你的距离+1。

- H
- CONST
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能
- CanTriggerMe
若为主动技，TRUE
- CanCast
若为锁定技，TRUE
- Resolve
- NetMsg
BroadcastSpellOptMsg//使用技能21212
- Data
- State
- TimeOutCallBack
- X
```cpp
role.cpp
YiCongJ::BroadcastSpellOptMsg(this,v_old,m_nCurHp);
```

## 趫猛Y
当你使用黑色牌指定其他角色为目标后，你可以弃置其中一个目标一张牌。若为装备牌，改为你获得之。若为锦囊牌，此牌不能被响应。
- H
技能流程：
step_beign = 0,
step_wait_discard,
step_after_discard,
step_end
- CONST
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机Opp_after_choose_target,Opp_usecard_action_after_choose_target
- CanTriggerMe
获取即时和延时牌的指定目标
空检查：牌区有牌
- CanCast
界限检查：弃牌目标为1
匹配检查：弃牌目标不为自己
是不是传下去的目标id	
- Resolve
- NetMsg
1. 发送可弃牌目标
AskClientResponseSpell
2. 接收弃牌/获得牌消息
NetMsgMoveCardRpyResult
- Data
- State
- TimeOutCallBack
随机弃置一张牌
## 怀异Y
出牌阶段限一次，你可以展示所有手牌。若只有一种颜色，你摸一张牌，然后此技能本阶段改为“出牌阶段限两次”；若有两种颜色，你弃置其中一种颜色的牌，然后获得至多X名角色的各一张牌（X为弃置的手牌数）。若你获得的牌大于1张，则你失去1点体力。

- H
技能流程：
step_begin = 0,//展示手牌
step_after_show_card,//判断颜色数
step_wait_sel_color,//选择弃牌颜色
step_after_sel_color,
step_after_discard,
step_wait_sel_target,//选择拿牌目标
step_ask_get_card,
step_wait_get_card,
step_after_get_card,//失去体力
step_end
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能SKILL_CHARACTER_SFMATCH_HUAI_YI = 21035
    - 注册技能类型`REGISTER_NORMAL_SPELL`
- CanTriggerMe
若为主动技，TRUE
- CanCast
界限检查：技能额外次数
- Resolve
1. step_after_sel_color
发送广播要弃置的颜色Broadcast(&msg)
- NetMsg
1. 发送请求要选择的颜色AskClientResponseSpell
1. 发送请求要选择的拿牌目标AskClientResponseSpell
1. 发送请求要选择的牌AskClientResponseSpell
1. 接收颜色/拿牌目标NetMsgRoleSpellOptRpyResult
1. 接收选择的牌NetMsgMoveCardRpyResult
- Data
重置或增加次数都会发送通知UpdateRoleData_Ex()
- State
- TimeOutCallBack
随机一个目标或随机一张牌

## 缮甲Y
出牌阶段开始时，你可以摸三张牌，然后弃置三张牌（本局游戏你每失去过一张装备牌，便少弃置一张），若你本次没有弃置过：基本牌，你此阶段可使用【杀】次数+1；锦囊牌，你此阶段使用牌无距离限制。若两者皆满足则可视为使用一张【杀【（不计入次数限制）。
- H
技能效果：
effect_deal_card = 1,//摸牌
effect_add_state = 2,//BUFF
技能流程：
step_begin = 0,//摸3
step_ask_discard,
step_wait_discard,
step_dis_card,
step_add_sha_times,
step_add_state,
step_ask_use_sha,
step_wait_use_sha,
step_end,
- CONST
出牌阶段限制次数3
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机Opp_when_enter_play_phase，Opp_play_card_zone_change
- CanTriggerMe
若为主动技，TRUE
- CanCast
//匹配检查：出牌阶段开始时，走摸牌效果
//匹配检查：卡牌区域改变时，计算失去装备牌数
- Resolve

- NetMsg
1. 发送选择弃置的牌AskClientResponseSpell
1. 接收选择弃置的牌
1. 发送无距离限制消息state->UpateDataToClient()
1. 发送虚拟杀选择的目标
1. 接收虚拟杀选择的目标
1. 接收取消使用虚拟杀
- Data
UpdateRoleData_Ex()发送失去的装备数
- State

CanRemove死亡时移除，其他时机保留
- TimeOutCallBack
随机弃置要求牌数

## 奋音S
你的回合内，每当你使用了一张与上一张颜色不同的牌时，你摸一张牌。
- H
- CONST
- REGISTER
    - `cardIdDefineEnumClass.h`枚举技能
    - 注册技能类型`REGISTER_TRIGGER_SPELL`
    - `trigger_action.cpp`注册时机Opp_when_use_card
- CanTriggerMe
若为主动技，TRUE
- CanCast
- Resolve
- NetMsg

- Data
data数组从旧到新是卡牌颜色
UpdateRoleData_Ex()
- State
- TimeOutCallBack

# 说明
## 常用文件
- 技能ID
cardldDefineEnumClass.h
- 时机注册
trigger_action.cpp
- 特殊牌区声明
role.h
- 特殊牌区状态设置
role.cpp
- 无视次数
sha.cpp
- 改变手牌上限
spellMgr.cpp
- 改变最大目标数
role_spell_data.cpp

## 常用时机注册
```cpp
//EmPriority pri = prior_begin时表示按照技能的类别自动划分
static TriggerSpell* register_opp(EmOpportunity oppType, unsigned int spellId, EmPriority pri = prior_begin, unsigned int mark = 0);

//注册时 添加mark
static TriggerSpell* register_opp_use_mark(EmOpportunity oppType, unsigned int spellId, unsigned int mark, EmPriority pri = prior_begin);

//注册技能后，技能有锁定触发标记 ex_mark:额外增加的标记
static TriggerSpell* register_opp_passive(EmOpportunity oppType, unsigned int spellId, unsigned int ex_mark = 0, EmPriority pri = prior_begin);

//延迟效果注册
static TriggerSpell* register_effect_opp(EmOpportunity oppType, unsigned int spellId, bool notifyUseSpell = false, EmPriority pri = prior_begin);
```

## 三服不同
- 宏-技能注册
```cpp
//新杀未声明自动类型
auto ID_RTS_XXX = (unsigned int)YOKA_SKILL::XXX;
REGISTER_TRIGGER_SPELL(YYY, ID_RTS_XXX);
REGISTER_SPELL_DATA_CREATE(ID_RTS_XXX, YYYData)

class YYY : public CSpell, public CreateXSpell<YYY, (unsigned int)YOKA_SKILL::XXX>
```
- 传参
```cpp
//新杀未使用指针传参
Roguelike_KuRou::Roguelike_KuRou(const CCardSpellData* pSpellData, CGame* pGame) : CSpell(pSpellData, pGame, step_begin)
{
}
//新杀使用.
CRole* pCaster = pParam->GetCaster();

//新杀不传递参数unsigned int fromId /*= 0*/, unsigned toId /*= 0*/
CMoveCardAction* pAc = CMoveCardAction::MoveCards(GetGame(), EmActMode::Mode_Get, pPlaycardList, ntf_seats, GetCaster()->GetSeatId(), GetCaster(), GetSpellId(), pSelCard->GetZone(), GetCaster()->GetHandCardZone(), pTarget->GetSeatId(), GetCasterSeatId());
```

- 命名
```cpp
//新杀bool OnEvent(const TEventParam& eventParam);
bool CanRemove(const TRemoveParam& eventParam);

//新杀auto role = pParam.GetRole();
CRole* pCaster = pParam->GetCaster();

//新杀pMsg.datas_size()
pMsg->data_count()
pMsg->card_count()

//新杀pMsg.datas(0)
pMsg->data[0]

//新杀DisCard(caster, m_vecDisCardList);
if (!DisCardFromRole(caster, caster, m_vecDisCardList))
    APPLOG_ERROR_GAME_LOGIC("Discard error" << FUN_FILE_LINE);

//新杀pShaData->AddExMaxTimesInPlayPhase(1);
pShaData->SetExCanUseShaTimesPhase(1);

//新杀if (!CMoveCardAction::RevealCardShowAll(GetGame(), caster->GetHandCardZone(), caster->GetHandCardZone().GetPlayCardList(), GetCaster(), GetSpellId(), 2 + caster->GetHandCardSize() / 2))
static SeatIdList ntf_seats{ MAX_TABLE_SEAT };
if (!CMoveCardAction::RevealCard(GetGame(), GetCaster(),GetSpellId(), caster->GetHandCardZone(), caster->GetHandCardZone()->GetPlayCardList(), ntf_seats,2 + caster->GetHandCardSize() / 2))

//新杀MsgRoleSpellOptRep msg;
msg.set_seat(GetCasterSeatId());
msg.set_opt_type(msg.OPT_SEL_COLOR);
msg.set_spell_id(GetSpellId());
msg.add_datas(m_sel_color);
GetGame().Broadcast(msg);

MsgRoleSpellOptRep msg;
msg.seatId = GetCasterSeatId();
msg.optType = MsgRoleSpellOptRep::OPT_SEL_COLOR;
msg.SpellId = GetSpellId();
msg.dataCnt = 1;
msg.data[0] = m_sel_color;
msg.Len = sizeof(msg) - (sizeof(msg.data[0]) * (msg.sc_max_data_cnt - msg.dataCnt));
GetGame()->Broadcast(&msg);

//新杀MsgUpdateRoleData_Ex_Ntf
msg.add_data(GetSpellUseTimes());
msg.add_data(m_add_times);

//新杀
void NetMsgRoleSpellOptRpy(const MsgRoleSpellOptRep* pMsg, CGsUser *pUser);
void NetMsgCancelRpy(const MsgClientRoleOptRep* pMsg, CGsUser *pUser);
void NetMsgMoveCardRpy(const MsgMoveCard* pMsg, CGsUser *pUser);

```

- 常用函数
```cpp
//新杀CheckTargetCanCast(GetGame()
if (CSpellMgr::single()->CheckTargetCanCast(*GetGame(), castParam, TSpellTarget{ seatId }) != SPELL_CAST_OK)

```

# 备注
1. 时机检测
时机检测可能作用每个人，因此需要匹配检查座位，例如CanTriggerMe检测受到伤害后，每名玩家受伤都会进入检测流程【烈节】
1. 能否弃置
任何主动弃置牌的技能中，都需要加入合法检测。CanDiscard需要判断三个特殊技能：杨婉【婉嫕】，董白【黠慧】，杨修【鸡肋】

# bug
- 编译

    - 无声明
    ```
    //.h增加以下头文件
    #include "../role.h"
    ```
    - 废弃函数
    禁用rpy(

    - 请使用obj编译
    https://blog.csdn.net/LLL_mg/article/details/110948965

- 技能

1. 【界关兴张苞】装备区的牌无法被父魂转化打出
注意装备区转化牌的api

1. 【咆哮】失去技能后标记未清除

# 测试常用
## 牌
- 基本
15-24   闪
45-48	桃
54-63	杀
130 酒

- 锦囊
27  万箭齐发
72  南蛮入侵
77-78   借刀
92	闪电
97	乐
144	兵
157-160	铁索连环

- 装备
12  方天画戟
103	丈八蛇矛
67	八卦阵
13  -1
52  +1
161 木牛流马
4308    霹雳车9
30100	思召剑
## 技能
- 敌方影响技能
138	断肠
885	缠怨

- buff
34  咆哮
206	鸡肋
374	伏骑

- 控制手牌和体力
31  仁德
62	苦肉
97	火计
209	离魂
306	业炎

- 兵乐自己
371	解围
402 酒诗
1500	萌态

- 转化虚拟
46	倾国
473	父魂
800	卫境

- 合法使用弃置
206	鸡肋

- 有标记的牌
401	落英
875	洛神
3407	重身
3491	酒诗

## 作弊
20000神戮	锁定技，当你使用牌时，你弃置每名其他角色所有牌，且此牌无法被响应。你造成的伤害为受伤角色的生命值。
20001静默	锁定技，游戏开始时，你获得“完杀”并令每名其他角色翻面。
20002双段	锁定技，你的首个准备/判定/摸牌/出牌/弃牌/结束阶段后执行一个额外的准备/判定/摸牌/出牌/弃牌/结束阶段阶段。
20003走马观花	锁定技，其他角色跳过准备/判定/摸牌/出牌/弃牌/结束阶段，当其他角色使用牌后结束该阶段，你的回合开始时失去该技能。
20004化骨	锁定技，当你使用牌时，你弃置每名其他角色所有牌并失去所有技能，且此牌无法被响应。你使用牌指定目标后，你令目标死亡。
20005轮到我了	锁定技，其他角色跳过准备/判定/摸牌/出牌/弃牌/结束阶段，当其他角色使用牌后结束该阶段，你的回合开始时失去该技能。
20006封印	锁定技，获得此技能时，废除自己的装备区和判定区。
